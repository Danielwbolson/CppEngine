#version 450 compatibility

#extension GL_ARB_compute_shader	: enable
#extension GL_ARB_bindless_texture	: enable
#extension GL_NV_gpu_shader5		: enable

#define rayMaxDist 10000000
#define MAX_VISITED_NODES 64
#define MAX_MATERIALS 32
#define SMALL_NUMBER 0.0001
#define REALLY_SMALL_NUMBER 0.0000000001
#define MAX_POINT_LIGHTS 500

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;


struct Ray {
	vec3 pos;
	vec3 dir;
	float tMax;
};

// Constant memory point lights
struct PointLightToGPU {
	vec4 position_and_radius;
	vec4 color_and_luminance;
};
layout(std140, binding = 0) uniform PointLightBUffer {
	PointLightToGPU pointLights[MAX_POINT_LIGHTS];
};

// Global memory materials buffer
//struct GPUMaterial {
//	sampler2D diffuseTexture;
//	sampler2D specularTexture;
//	sampler2D specularHighlightTexture;
//	sampler2D normalTexture;
//	sampler2D alphaTexture;
//	
//	sampler2D pad [3];
//
////	u8vec4 diffuse;
////	u8vec4 specular;
////	u8vec4 transmissive;
////	float specularExponent;
////	float indexOfRefraction;
////	uint8_t usingNormal;
////	uint8_t pad[3];
//};
//layout (std140, binding = 1) uniform Materials {
//	GPUMaterial materials[MAX_MATERIALS];
//};

// Global memory bvh
struct LinearBVHNode {
	vec3 boundsMin;
	uint offset; // leaf node - primitiveOffset, interior node - secondChildOffset

	vec3 boundsMax;
	uint numPrimitives;

	uint axis;
	uint pad[3];
};
layout (std430, binding = 2) readonly buffer BVH {
	LinearBVHNode nodes[];
};

// Global memory vertex buffer
struct GPUVertex {
	vec4 position;
	vec4 normal;
	vec4 uv;
	vec4 tangents;
};
layout (std430, binding = 3) readonly buffer Vertices {
	GPUVertex vertices[];
};

// Global memory triangle buffer
struct GPUTriangle {
	uint indices[3];
	uint materialIndex;
};
layout (std430, binding = 4) readonly buffer Triangles {
	GPUTriangle triangles[];
};

layout (binding = 0) uniform writeonly image2D destTex;

uniform mat4 proj;
uniform mat4 invProj;

uniform mat4 view;
uniform mat4 invView;

uniform vec3 camPos;
uniform uint numPointLights;

struct Intersection {
	GPUTriangle triangle;
	vec3 normal;
	float u;
	vec3 point;
	float v;
};

bool BVHIntersect(inout Ray ray, inout Intersection intersection, inout vec3 finalColor);
bool TriangleIntersect(in GPUTriangle triangle, inout Ray ray, inout Intersection intersection);
bool AABBIntersectRay(in vec3 boundsMin, in vec3 boundsMax, in Ray ray, in vec3 invDir, in ivec3 dirIsNeg);

void main() {

	// position in global shader (texture position)
	ivec2 globalId = ivec2(gl_GlobalInvocationID.xy);
	ivec2 resolution = imageSize(destTex);
	float aspectRatio = resolution.x / resolution.y;

	// Compute our thread into world space coordinates
	vec2 rayUV = vec2(globalId.x / float(resolution.x), globalId.y / float(resolution.y));
	vec4 rayNDC = vec4(2.0 * rayUV - 1.0, 1.0, 1.0);
	vec4 rayViewSpace = invProj * rayNDC;
	rayViewSpace /= rayViewSpace.w;
	vec3 rayWorldSpace = (invView * rayViewSpace).xyz;

	// Create our ray
	Ray ray;
	ray.pos = camPos;
	ray.dir = normalize(rayWorldSpace - camPos);
	ray.tMax = rayMaxDist;

	// We now have a world space ray. We can intersect our BVH and calculate lighting.
	vec3 finalColor = vec3(0,0,0);
	Intersection intersection;
//
//	bool hit = false;
//	for (uint i = 0; i < triangles.length(); i+=1) {
//		if (TriangleIntersect(triangles[i], ray, intersection)) {
//			hit = true;
//			break;
//		}
//	}
//
//	if (hit) {
//		finalColor = vec3(0,1,0);
//	}
	if (BVHIntersect(ray, intersection, finalColor)) {
		GPUVertex a = vertices[intersection.triangle.indices[0]];
		GPUVertex b = vertices[intersection.triangle.indices[1]];
		GPUVertex c = vertices[intersection.triangle.indices[2]];
		vec2 triUvs = (a.uv * (1.0 - intersection.u - intersection.v) + b.uv * intersection.u + c.uv * intersection.v).xy;
		//finalColor = texture(materials[intersection.triangle.materialIndex].diffuseTexture, triUvs).xyz;
		finalColor = vec3(triUvs,0.0);
	}

	imageStore(destTex, globalId, vec4(finalColor, 1));
}

bool BVHIntersect(inout Ray ray, inout Intersection intersection, inout vec3 finalColor) {
	bool hit = false;

	vec3 invDir = 1.0 / ray.dir;
	ivec3 dirIsNeg = ivec3(invDir.x < 0, invDir.y < 0, invDir.z < 0);

	uint toVisitOffset = 0; 
	uint currentNodeIndex = 0;
	uint nodesToVisit[MAX_VISITED_NODES];

	while (true) {
		// Cap on number of nodes we can visit
		if (toVisitOffset >= MAX_VISITED_NODES) {
			finalColor = vec3(0,0,1);
			return false;
		}

		LinearBVHNode node = nodes[currentNodeIndex];
		// If this node intersects with our ray
		if (AABBIntersectRay(node.boundsMin, node.boundsMax, ray, invDir, dirIsNeg)) {

			// Leaf node. Check all triangles within this leaf node.
			if (node.numPrimitives > 0) {

				for (uint i = 0; i < node.numPrimitives; i+=1) {
					if (TriangleIntersect(triangles[node.offset + i], ray, intersection)) {
						hit = true;
					}
				}

				if (toVisitOffset == 0) {
					break;
				}
				currentNodeIndex = nodesToVisit[--toVisitOffset];
			}
			// Interior node. Check children nodes, using direction of ray to determine which child to check first.
			else {
				if (dirIsNeg[node.axis] > 0) {
					nodesToVisit[toVisitOffset++] = currentNodeIndex + 1;
					currentNodeIndex = node.offset;
				}
				else {
					nodesToVisit[toVisitOffset++] = node.offset;
					currentNodeIndex = currentNodeIndex + 1;
				}
			}
		}
		// No intersection. Check next node.
		else {
			if (toVisitOffset == 0) {
				break;
			}
			currentNodeIndex = nodesToVisit[--toVisitOffset];
		}
	} // while

	return hit;

}

/* https://en.wikipedia.org/wiki/Cramer%27s_rule */
/* https://www.cs.cornell.edu/courses/cs4620/2015fa/lectures/06rtintersectWeb.pdf */
/* https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection */
bool TriangleIntersect(in GPUTriangle triangle, inout Ray ray, inout Intersection intersection) {

	// Plane normal and triangle area
	GPUVertex a = vertices[triangle.indices[0]];
	GPUVertex b = vertices[triangle.indices[1]];
	GPUVertex c = vertices[triangle.indices[2]];

	vec3 a_to_b = b.position.xyz - a.position.xyz;
	vec3 a_to_c = c.position.xyz - a.position.xyz;
	vec3 pVec = cross(ray.dir, a_to_c);
	float det = dot(a_to_b, pVec);

	// If we are parallel
	if (abs(det) < SMALL_NUMBER) {
		return false;
	}

	// Avoid excess divides
	float invDet = 1.0 / det;

	// Calculate u
	vec3 uVec = ray.pos - a.position.xyz;
	float u = dot(uVec, pVec) * invDet; // how far does this uVec go in dir of our ray
	if (u < 0.0 || u > 1.0) return false;

	// Calculate v
	vec3 vVec = cross(uVec, a_to_b);
	float v = dot(ray.dir, vVec) * invDet; // how far does this vVec go in dir of our ray
	if (v < 0.0 || u + v > 1.0) return false;

	// Calculate t (behind or past closest triangle).
	float t = dot(a_to_b, vVec) * invDet;
	if (t < 0.0 || t > ray.tMax) return false;

	// In the triangle	
	ray.tMax = t;
	
	intersection.triangle = triangle;
	vec3 barycentricNormal = ((1.0 - u - v) * a.normal.xyz + u * b.normal.xyz + v * c.normal.xyz).xyz;
	vec3 normal = normalize(barycentricNormal);
	intersection.normal = normal;
	intersection.u = u;
	intersection.point = ray.pos + t * ray.dir;
	intersection.v = v;

	return true;
}

bool AABBIntersectRay(in vec3 boundsMin, in vec3 boundsMax, in Ray ray, in vec3 invDir, in ivec3 dirIsNeg) {

	vec3 slabs [2] = { boundsMin, boundsMax };

	float tMin  = ( slabs[  dirIsNeg[0]].x	- ray.pos.x) * invDir.x;
	float tMax  = ( slabs[1-dirIsNeg[0]].x	- ray.pos.x) * invDir.x;
	float tyMin = ( slabs[  dirIsNeg[1]].y	- ray.pos.y) * invDir.y;
	float tyMax	= ( slabs[1-dirIsNeg[1]].y	- ray.pos.y) * invDir.y;

	if (tMin > tyMax || tyMin > tMax) {
		return false;
	}
	if (tyMin > tMin) tMin = tyMin;
	if (tyMax < tMax) tMax = tyMax;

	float tzMin = ( slabs[  dirIsNeg[2]].z	- ray.pos.z) * invDir.z;
	float tzMax = ( slabs[1-dirIsNeg[2]].z	- ray.pos.z) * invDir.z;

	if (tMin > tzMax || tzMin > tMax) {
		return false;
	}
	if (tzMin > tMin) tMin = tzMin;
	if (tzMax < tMax) tMax = tzMax;

	return (tMin < ray.tMax) && (tMax > 0);
}


/***** * * * * * Deprecated functions * * * * * *****/
// This didn't work with Cramers rule.
/* https://en.wikipedia.org/wiki/Cramer%27s_rule */
/* https://www.cs.cornell.edu/courses/cs4620/2015fa/lectures/06rtintersectWeb.pdf */
bool DeprecatedTriangleIntersect(in GPUTriangle triangle, inout Ray ray, inout Intersection intersection) {

	// Plane normal and triangle area
	GPUVertex a = vertices[triangle.indices[0]];
	GPUVertex b = vertices[triangle.indices[1]];
	GPUVertex c = vertices[triangle.indices[2]];

	vec3 a_to_b = b.position.xyz - a.position.xyz;
	vec3 a_to_c = c.position.xyz - a.position.xyz;
	vec3 p_to_a = a.position.xyz - ray.pos;

	// Calculate if triangle and ray are parallel.
	// If normal of triangle and ray are perpendicular, then they are parallel.
	if (abs(dot(cross(a_to_b, a_to_c), p_to_a)) < SMALL_NUMBER) return false;

	mat3 mat = mat3( a_to_b, a_to_c, ray.dir);
	double det = determinant(mat);
	if (abs(det) < SMALL_NUMBER) return false;
	det = 1.0 / det;

	// Calculate u
	mat[0] = p_to_a;
	float u = float(determinant(mat) * det);
	if (u < 0.0 || u > 1.0) return false;

	// Calculate v
	mat[0] = a_to_b;
	mat[1] = p_to_a;
	float v = float(determinant(mat) * det);
	if (v < 0.0 || u + v > 1.0) return false;

	// Calculate t (behind or past closest triangle).
	mat[1] = a_to_c;
	mat[2] = p_to_a;
	float t = float(determinant(mat) * det);
	if (t < 0.0 || t > ray.tMax) return false;

	// In the triangle	
	ray.tMax = t;
	
	intersection.triangle = triangle;
	vec3 barycentricNormal = ((1.0 - u - v) * a.normal.xyz + u * b.normal.xyz + v * c.normal.xyz).xyz;
	vec3 normal = normalize(barycentricNormal);
	intersection.normal = normal;
	intersection.u = u;
	intersection.point = ray.pos + t * ray.dir;
	intersection.v = v;

	return true;
}
