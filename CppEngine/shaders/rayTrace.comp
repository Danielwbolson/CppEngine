#version 450 compatibility

#extension GL_ARB_compute_shader	: enable
#extension GL_ARB_bindless_texture	: enable
#extension GL_NV_gpu_shader5		: enable

#define rayMaxDist 10000000
#define MAX_VISITED_NODES 64
#define MAX_MATERIALS 32
#define SMALL_NUMBER 0.0001
#define REALLY_SMALL_NUMBER 0.0000001
#define MAX_POINT_LIGHTS 512
#define WORK_GROUP_SIZE 16
#define LIGHTING_NO_MATERIALS 0

layout(local_size_x = WORK_GROUP_SIZE, local_size_y = WORK_GROUP_SIZE, local_size_z = 1) in;


/***** * * * * * Ray tracing Structs * * * * * *****/

struct Ray {
	vec3 pos;
	vec3 dir;
	float tMax;
};
struct Intersection {
	vec3 point;
	vec3 normal;
	vec2 uvs;
	uint materialIndex;
};


/***** * * * * * Buffers * * * * * *****/

//struct PointLightToGPU {
//	vec4 position_and_radius;
//	vec4 color_and_luminance;
//};
//layout(std140, binding = 0) uniform PointLightBUffer {
//	PointLightToGPU pointLights[MAX_POINT_LIGHTS];
//}; // Constant

struct GPUMaterial {
	uint64_t diffuseTexture;
	uint64_t normalTexture;

	uint64_t alphaTexture;
	uint diffuse; // 8/8/8/NA
	uint specular; // 8/8/8/NA

	uint transmissive_and_ior; // 8/8/8/8
	uint specularExponent_and_usingNormal; // 16/16
	uint64_t pad;
};
layout (std140, binding = 1) uniform Materials {
	GPUMaterial materials[MAX_MATERIALS];
}; // Constant

struct LinearBVHNode {
	vec3 boundsMin;
	uint offset; // leaf node - primitiveOffset, interior node - secondChildOffset

	vec3 boundsMax;
	uint numPrimitives_and_axis; // 16/16
};
layout (std430, binding = 2) readonly buffer BVH {
	LinearBVHNode nodes[];
}; // Global

struct GPUVertex {
	vec4 position_and_u;
	vec4 normal_and_v;
	vec4 tangent;
	vec4 bitangent;
};
layout (std430, binding = 3) readonly buffer Vertices {
	GPUVertex vertices[];
}; // Global

struct GPUTriangle {
	uint indices[3];
	uint materialIndex;
};
layout (std430, binding = 4) readonly buffer Triangles {
	GPUTriangle triangles[];
}; // Global

layout (binding = 0) uniform writeonly image2D destTex;


/***** * * * * * Uniforms * * * * * *****/

uniform mat4 proj;
uniform mat4 invProj;

uniform mat4 view;
uniform mat4 invView;

uniform vec3 camPos;
uniform uint numPointLights;

uniform vec3 directionalLightDir;
uniform vec3 directionalLightCol;


/***** * * * * * Functions Declarations * * * * * *****/

bool BVHIntersect(inout Ray ray, inout Intersection intersection);
bool TriangleIntersect(in GPUTriangle triangle, inout Ray ray, inout Intersection intersection);
bool AABBIntersectRay(in vec3 boundsMin, in vec3 boundsMax, in Ray ray, in vec3 invDir, in ivec3 dirIsNeg);

vec3 Lighting(in Intersection intersection);
vec3 LightingNoMaterials(in Intersection intersection);

bool FastBVHIntersect(in Ray ray);
bool FastTriangleIntersect(in GPUTriangle triangle, in Ray ray);


/***** * * * * * MAIN * * * * * *****/

void main() {

	// position in global shader (texture position)
	ivec2 globalId = ivec2(gl_GlobalInvocationID.xy);
	ivec2 resolution = imageSize(destTex);
	float aspectRatio = resolution.x / resolution.y;

	// Compute our thread into world space coordinates
	vec2 rayUV = vec2(globalId.x / float(resolution.x), globalId.y / float(resolution.y));
	vec4 rayNDC = vec4(2.0 * rayUV - 1.0, 1.0, 1.0);
	vec4 rayViewSpace = invProj * rayNDC;
	rayViewSpace /= rayViewSpace.w;
	vec3 rayWorldSpace = (invView * rayViewSpace).xyz;

	// Create our ray
	Ray ray;
	ray.pos = camPos;
	ray.dir = normalize(rayWorldSpace - camPos);
	ray.tMax = rayMaxDist;

	// We now have a world space ray. We can intersect our BVH and calculate lighting.
	vec3 finalColor = vec3(0,0,0);
	Intersection intersection;

	if (BVHIntersect(ray, intersection)) {
#if LIGHTING_NO_MATERIALS
		finalColor += LightingNoMaterials(intersection);
#else
		finalColor += Lighting(intersection);
#endif
	}

	imageStore(destTex, globalId, vec4(finalColor, 1));
}


/***** * * * * * Functions Definitions * * * * * *****/

bool BVHIntersect(inout Ray ray, inout Intersection intersection) {
	bool hit = false;

	vec3 invDir = vec3(1.0 / ray.dir.x, 1.0 / ray.dir.y, 1.0 / ray.dir.z);
	ivec3 dirIsNeg = ivec3(invDir.x < 0, invDir.y < 0, invDir.z < 0);

	uint toVisitOffset = 0; 
	uint currentNodeIndex = 0;
	uint nodesToVisit[MAX_VISITED_NODES];

	while (true) {
		// Cap on number of nodes we can visit
		if (toVisitOffset >= MAX_VISITED_NODES) return false;

		LinearBVHNode node = nodes[currentNodeIndex];
		// If this node intersects with our ray
		if (AABBIntersectRay(node.boundsMin, node.boundsMax, ray, invDir, dirIsNeg)) {

			// Leaf node. Check all triangles within this leaf node.
			uint numPrimitives = (node.numPrimitives_and_axis >> 16);
			if (numPrimitives > 0) {

				for (uint i = 0; i < numPrimitives; i+=1) {
					if (TriangleIntersect(triangles[node.offset + i], ray, intersection)) {
						hit = true;
					}
				}

				if (toVisitOffset == 0) {
					break;
				}
				currentNodeIndex = nodesToVisit[--toVisitOffset];
			}
			// Interior node. Check children nodes, using direction of ray to determine which child to check first.
			else {
				if (dirIsNeg[(node.numPrimitives_and_axis & 0xFFFF)] > 0) {
					nodesToVisit[toVisitOffset++] = currentNodeIndex + 1;
					currentNodeIndex = node.offset;
				}
				else {
					nodesToVisit[toVisitOffset++] = node.offset;
					currentNodeIndex = currentNodeIndex + 1;
				}
			}
		}
		// No intersection. Check next node.
		else {
			if (toVisitOffset == 0) {
				break;
			}
			currentNodeIndex = nodesToVisit[--toVisitOffset];
		}
	} // while

	return hit;

}

// Attempted with Cramers rul but didn't work. Not sure why.
/* https://en.wikipedia.org/wiki/Cramer%27s_rule */
/* https://www.cs.cornell.edu/courses/cs4620/2015fa/lectures/06rtintersectWeb.pdf */
// Using this method.
/* https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection */
bool TriangleIntersect(in GPUTriangle triangle, inout Ray ray, inout Intersection intersection) {

	// Plane normal and triangle area
	GPUVertex a = vertices[triangle.indices[0]];
	GPUVertex b = vertices[triangle.indices[1]];
	GPUVertex c = vertices[triangle.indices[2]];

	vec3 a_to_b = b.position_and_u.xyz - a.position_and_u.xyz;
	vec3 a_to_c = c.position_and_u.xyz - a.position_and_u.xyz;
	vec3 pVec = cross(ray.dir, a_to_c);
	float det = dot(a_to_b, pVec);

	// If we are parallel
	if (abs(det) < SMALL_NUMBER) return false;

	// Avoid excess divides
	float invDet = 1.0 / det;

	// Calculate u
	vec3 uVec = ray.pos - a.position_and_u.xyz;
	float u = dot(uVec, pVec) * invDet; // how far does this uVec go in dir of our ray
	if (u < 0.0 || u > 1.0) return false;

	// Calculate v
	vec3 vVec = cross(uVec, a_to_b);
	float v = dot(ray.dir, vVec) * invDet; // how far does this vVec go in dir of our ray
	if (v < 0.0 || u + v > 1.0) return false;

	// Calculate t (behind or past closest triangle).
	float t = dot(a_to_c, vVec) * invDet;
	if (t < 0.0 || t > ray.tMax) return false;

	// Check against alpha
	vec2 aUvs = vec2(a.position_and_u.w, a.normal_and_v.w);
	vec2 bUvs = vec2(b.position_and_u.w, b.normal_and_v.w);
	vec2 cUvs = vec2(c.position_and_u.w, c.normal_and_v.w);
	vec2 uvs = (aUvs * (1.0 - u - v) + bUvs * u + cUvs * v);
	float alpha = texture(sampler2D(materials[triangle.materialIndex].alphaTexture), uvs).r;
	if (alpha < SMALL_NUMBER) return false;

	// In the triangle
	ray.tMax = t;
	
	intersection.point = ray.pos + t * ray.dir;
	vec3 normal = normalize(((1.0 - u - v) * a.normal_and_v.xyz + u * b.normal_and_v.xyz + v * c.normal_and_v.xyz).xyz);
#if LIGHTING_NO_MATERIALS
	intersection.normal = normal;
#else
	bool usingNormal = (materials[triangle.materialIndex].specularExponent_and_usingNormal & 0xFFFF) > 0;
	if (usingNormal) {
		vec3 tangent = normalize(((1.0 - u - v) * a.tangent.xyz + u * b.tangent.xyz + v * c.tangent.xyz).xyz);
		vec3 bitangent = normalize(((1.0 - u - v) * a.bitangent.xyz + u * b.bitangent.xyz + v * c.bitangent.xyz).xyz);
		vec3 n = texture(sampler2D(materials[intersection.materialIndex].normalTexture), uvs).xyz;
		mat3 tbn = mat3(tangent, bitangent, normal);
		intersection.normal = normalize(tbn * n);
	}
	else {
		intersection.normal = normal;
	}
#endif
	intersection.uvs = uvs;
	intersection.materialIndex = triangle.materialIndex;

	return true;
}

bool AABBIntersectRay(in vec3 boundsMin, in vec3 boundsMax, in Ray ray, in vec3 invDir, in ivec3 dirIsNeg) {

	vec3 slabs [2] = { boundsMin, boundsMax };

	float tMin  = ( slabs[  dirIsNeg[0]].x	- ray.pos.x) * invDir.x;
	float tMax  = ( slabs[1-dirIsNeg[0]].x	- ray.pos.x) * invDir.x;
	float tyMin = ( slabs[  dirIsNeg[1]].y	- ray.pos.y) * invDir.y;
	float tyMax	= ( slabs[1-dirIsNeg[1]].y	- ray.pos.y) * invDir.y;

	if (tMin > tyMax || tyMin > tMax) {
		return false;
	}
	if (tyMin > tMin) tMin = tyMin;
	if (tyMax < tMax) tMax = tyMax;

	float tzMin = ( slabs[  dirIsNeg[2]].z	- ray.pos.z) * invDir.z;
	float tzMax = ( slabs[1-dirIsNeg[2]].z	- ray.pos.z) * invDir.z;

	if (tMin > tzMax || tzMin > tMax) {
		return false;
	}
	if (tzMin > tMin) tMin = tzMin;
	if (tzMax < tMax) tMax = tzMax;

	return (tMin < ray.tMax) && (tMax > 0);
}

vec3 Lighting(in Intersection intersection) {
	vec3 outColor = vec3(0,0,0);

	// First, calculate if our light is even in the same direction.
	float nDotL = dot(intersection.normal, -directionalLightDir);

	if (nDotL > 0.0) {
		GPUMaterial mat = materials[intersection.materialIndex];

		// Unpack our color data
		vec3 diffuseCoef = vec3(
			((mat.diffuse >> 24) & 0xFF) / 255.0f, 
			((mat.diffuse >> 16) & 0xFF) / 255.0f, 
			((mat.diffuse >> 8) & 0xFF) / 255.0f
		);
		vec3 specularCoef = vec3(
			((mat.specular >> 24) & 0xFF) / 255.0f, 
			((mat.specular >> 16) & 0xFF) / 255.0f, 
			((mat.specular >> 8) & 0xFF) / 255.0f
		);
		float specularExponent = (mat.specularExponent_and_usingNormal >> 16) / 65535.0f;

		// Diffuse
		vec3 diffuseColor =
			directionalLightCol * 
			texture(sampler2D(mat.diffuseTexture), intersection.uvs).xyz *
			diffuseCoef *
			nDotL;

		// Specular
		vec3 eye = normalize(camPos - intersection.point);
		vec3 h = normalize(-directionalLightDir + eye);
		float spec = pow(max(dot(h, intersection.normal), 0.0), specularExponent);
		vec3 specularColor = specularCoef * spec;

		// Shadow
		Ray ray;
		ray.pos = intersection.point + SMALL_NUMBER * intersection.normal;
		ray.dir = -directionalLightDir;
		ray.tMax = rayMaxDist;
		bool inShadow = FastBVHIntersect(ray);

		// Total color
		outColor += (1 - (int)inShadow) * (diffuseColor + specularColor);
	}

	return outColor;
}

vec3 LightingNoMaterials(in Intersection intersection) {
	vec3 outColor = vec3(0,0,0);

	// First, calculate if our light is even in the same direction.
	float nDotL = dot(intersection.normal, -directionalLightDir);

	if (nDotL > 0.0) {

		float specularExponent = 10;

		// Diffuse
		vec3 diffuseColor = vec3(1,0,0);

		// Specular
		vec3 eye = normalize(camPos - intersection.point);
		vec3 h = normalize(-directionalLightDir + eye);
		float spec = pow(max(dot(h, intersection.normal), 0.0), specularExponent);
		vec3 specularColor = vec3(0.5,0.5,0.5) * spec;

		// Shadow
		Ray ray;
		ray.pos = intersection.point + SMALL_NUMBER * intersection.normal;
		ray.dir = -directionalLightDir;
		ray.tMax = rayMaxDist;
		bool inShadow = FastBVHIntersect(ray);

		// Total color
		outColor += (1 - (int)inShadow) * (diffuseColor + specularColor);
	}

	return outColor;
}

// Same as BVH intersect but exiting after intersection with any triangle.
bool FastBVHIntersect(in Ray ray) {

	vec3 invDir = vec3(1.0 / ray.dir.x, 1.0 / ray.dir.y, 1.0 / ray.dir.z);
	ivec3 dirIsNeg = ivec3(invDir.x < 0, invDir.y < 0, invDir.z < 0);

	uint toVisitOffset = 0; 
	uint currentNodeIndex = 0;
	uint nodesToVisit[MAX_VISITED_NODES];

	while (true) {
		// Cap on number of nodes we can visit
		if (toVisitOffset >= MAX_VISITED_NODES) return false;

		LinearBVHNode node = nodes[currentNodeIndex];
		// If this node intersects with our ray
		if (AABBIntersectRay(node.boundsMin, node.boundsMax, ray, invDir, dirIsNeg)) {

			// Leaf node. Check all triangles within this leaf node.
			uint numPrimitives = (node.numPrimitives_and_axis >> 16);
			if (numPrimitives > 0) {

				for (uint i = 0; i < numPrimitives; i+=1) {
					if (FastTriangleIntersect(triangles[node.offset + i], ray)) {
						return true;
					}
				}

				if (toVisitOffset == 0) {
					break;
				}
				currentNodeIndex = nodesToVisit[--toVisitOffset];
			}
			// Interior node. Check children nodes, using direction of ray to determine which child to check first.
			else {
				if (dirIsNeg[(node.numPrimitives_and_axis & 0xFFFF)] > 0) {
					nodesToVisit[toVisitOffset++] = currentNodeIndex + 1;
					currentNodeIndex = node.offset;
				}
				else {
					nodesToVisit[toVisitOffset++] = node.offset;
					currentNodeIndex = currentNodeIndex + 1;
				}
			}
		}
		// No intersection. Check next node.
		else {
			if (toVisitOffset == 0) {
				break;
			}
			currentNodeIndex = nodesToVisit[--toVisitOffset];
		}
	} // while

	return false;
}

// Same as TriangleIntersect but not saving intersection data.
bool FastTriangleIntersect(in GPUTriangle triangle, in Ray ray) {
	
	// Plane normal and triangle area
	GPUVertex a = vertices[triangle.indices[0]];
	GPUVertex b = vertices[triangle.indices[1]];
	GPUVertex c = vertices[triangle.indices[2]];

	vec3 a_to_b = b.position_and_u.xyz - a.position_and_u.xyz;
	vec3 a_to_c = c.position_and_u.xyz - a.position_and_u.xyz;
	vec3 pVec = cross(ray.dir, a_to_c);
	float det = dot(a_to_b, pVec);

	// If we are parallel
	if (abs(det) < SMALL_NUMBER) return false;

	// Avoid excess divides
	float invDet = 1.0 / det;

	// Calculate u
	vec3 uVec = ray.pos - a.position_and_u.xyz;
	float u = dot(uVec, pVec) * invDet; // how far does this uVec go in dir of our ray
	if (u < 0.0 || u > 1.0) return false;

	// Calculate v
	vec3 vVec = cross(uVec, a_to_b);
	float v = dot(ray.dir, vVec) * invDet; // how far does this vVec go in dir of our ray
	if (v < 0.0 || u + v > 1.0) return false;

	// Calculate t (behind or past closest triangle).
	float t = dot(a_to_c, vVec) * invDet;
	if (t < 0.0 || t > ray.tMax) return false;

	// Check against alpha
	vec2 aUvs = vec2(a.position_and_u.w, a.normal_and_v.w);
	vec2 bUvs = vec2(b.position_and_u.w, b.normal_and_v.w);
	vec2 cUvs = vec2(c.position_and_u.w, c.normal_and_v.w);
	vec2 uvs = (aUvs * (1.0 - u - v) + bUvs * u + cUvs * v);
	float alpha = texture(sampler2D(materials[triangle.materialIndex].alphaTexture), uvs).r;
	if (alpha < SMALL_NUMBER) return false;

	// In the triangle
	return true;
}