#version 450 compatibility
#extension GL_ARB_compute_shader : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout (binding = 0) uniform sampler2D gNormal;
layout (binding = 1) uniform usampler2D gDiffuseSpec;
layout (binding = 2) uniform sampler2D gDepth;

layout (binding = 0) uniform writeonly image2D destTex;

// Used for frustum calculations
uniform mat4 projView;

// Used for recreation of position from depth
uniform mat4 invProj;
uniform mat4 invView;

// Used for specular lighting
uniform vec3 camPos;

//uniform int numPointLights;
//uniform int numDirectionalLights;

shared uint minDepth;
shared uint maxDepth;

struct PointLightToGPU {
	vec4 position;
	vec3 color;
	float luminance;
};
layout(std430, binding = 0) buffer PointLights {
	PointLightToGPU pointLights[];
};

struct DirectionalLightToGPU {
	vec4 direction;
	vec4 color;
};
layout(std430, binding = 1) buffer DirectionalLights {
	DirectionalLightToGPU directionalLights[];
};

//// each tile supports 128 unique lights
//struct Tile {
//	int pointLights[123]; // 123 point lights supported
//	int numTilePointLights;
//
//	int directionalLights[3]; // 3 directional lights supported
//	int numTileDirLights;
//};
//layout(std430, binding = 2) buffer LightTiles {
//	Tile lightTiles[];
//};


// AABB detection of point lights against our tiles frustum
// Each tile has a camera frustum

void main() {

	// position in local work grop
	ivec2 localId = ivec2(gl_LocalInvocationID.xy);

	// position in global shader (texture position)
	ivec2 globalId = ivec2(gl_GlobalInvocationID.xy);

	// Get depth value from texture
	float depthFloat = texture(gDepth, globalId).r;

	uint depthInt = uint(depthFloat * 0xfffffffu);

	// Calculate min/max depth of out work group or tile
	atomicMax(maxDepth, depthInt);
	atomicMin(minDepth, depthInt);

	// At this point, we need all threads in the same work group to finish their above calculations
	barrier();


	// Reset out min/max depth values for this tile to floats
	float maxDepthFloat = float(float(maxDepth) / float(0xfffffffu));
	float minDepthFloat = float(float(minDepth) / float(0xfffffffu));

	ivec2 resolution = imageSize(destTex);

	// We need to convert our tile's frustum to the correct scale and position
	// We can use gl_WorkGroupSize since our x and y are the same (16x16)
	// TODO: I don't understand why 2 is in the denominator. Makes sense to me to not have it.
	vec2 tileScale = resolution * (1.0f / float(2.0f * gl_WorkGroupSize.x));
	vec2 tileBias = tileScale - vec2(gl_WorkGroupID.xy);

	// Calculate frustum planes
	// We want to calculate lighting in world space since our lights and camera are in that space
	// Thus, we want to calculate frustum planes using a proj * view matrix, not just proj
	// We are calculating our tile-specific frustum with tileScale and tileBias
	/* https://gamedev.stackexchange.com/questions/108442/tiled-deferred-rendering-light-culling */

	vec4 col1 = vec4(-projView[0][0] * tileScale.x, projView[0][1], tileBias.x, projView[0][3]);
	vec4 col2 = vec4(projView[1][0], -projView[1][1] * tileScale.y, tileBias.y, projView[1][3]);
	vec4 col4 = vec4(projView[3][0], projView[3][1], -1.0, projView[3][3]);

	vec4 frustumPlanes[6];
	//left
	frustumPlanes[0] = col4 + col1;
	//right
	frustumPlanes[1] = col4 - col1;
	//bottom
	frustumPlanes[2] = col4 + col2;
	//top
	frustumPlanes[3] = col4 - col2;
	//near
	frustumPlanes[4] = vec4(0.0f, 0.0f, -1.0f, -minDepthFloat); // why negative min depth?
	//far
	frustumPlanes[4] = vec4(0.0f, 0.0f, -1.0f, maxDepthFloat);

	// TODO : Should we normalize the frustum planes?

	// We need all threads to fully create their frustums before continuing
	barrier();

	// Light culling
}